// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: ibc/core/channel/v2/packet.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// PacketStatus specifies the status of a RecvPacketResult.
enum Ibc_Core_Channel_V2_PacketStatus: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// PACKET_STATUS_UNSPECIFIED indicates an unknown packet status.
  case unspecified // = 0

  /// PACKET_STATUS_SUCCESS indicates a successful packet receipt.
  case success // = 1

  /// PACKET_STATUS_FAILURE indicates a failed packet receipt.
  case failure // = 2

  /// PACKET_STATUS_ASYNC indicates an async packet receipt.
  case async // = 3
  case UNRECOGNIZED(Int)

  init() {
    self = .unspecified
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .success
    case 2: self = .failure
    case 3: self = .async
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .success: return 1
    case .failure: return 2
    case .async: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Ibc_Core_Channel_V2_PacketStatus: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Ibc_Core_Channel_V2_PacketStatus] = [
    .unspecified,
    .success,
    .failure,
    .async,
  ]
}

#endif  // swift(>=4.2)

/// Packet defines a type that carries data across different chains through IBC
struct Ibc_Core_Channel_V2_Packet {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// number corresponds to the order of sends and receives, where a Packet
  /// with an earlier sequence number must be sent and received before a Packet
  /// with a later sequence number.
  var sequence: UInt64 = 0

  /// identifies the sending client on the sending chain.
  var sourceClient: String = String()

  /// identifies the receiving client on the receiving chain.
  var destinationClient: String = String()

  /// timeout timestamp in seconds after which the packet times out.
  var timeoutTimestamp: UInt64 = 0

  /// a list of payloads, each one for a specific application.
  var payloads: [Ibc_Core_Channel_V2_Payload] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Payload contains the source and destination ports and payload for the application (version, encoding, raw bytes)
struct Ibc_Core_Channel_V2_Payload {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// specifies the source port of the packet.
  var sourcePort: String = String()

  /// specifies the destination port of the packet.
  var destinationPort: String = String()

  /// version of the specified application.
  var version: String = String()

  /// the encoding used for the provided value.
  var encoding: String = String()

  /// the raw bytes for the payload.
  var value: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Acknowledgement contains a list of all ack results associated with a single packet.
/// In the case of a successful receive, the acknowledgement will contain an app acknowledgement
/// for each application that received a payload in the same order that the payloads were sent
/// in the packet.
/// If the receive is not successful, the acknowledgement will contain a single app acknowledgment
/// which will be a constant error acknowledgment as defined by the IBC v2 protocol.
struct Ibc_Core_Channel_V2_Acknowledgement {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var appAcknowledgements: [Data] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// RecvPacketResult speecifies the status of a packet as well as the acknowledgement bytes.
struct Ibc_Core_Channel_V2_RecvPacketResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// status of the packet
  var status: Ibc_Core_Channel_V2_PacketStatus = .unspecified

  /// acknowledgement of the packet
  var acknowledgement: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Ibc_Core_Channel_V2_PacketStatus: @unchecked Sendable {}
extension Ibc_Core_Channel_V2_Packet: @unchecked Sendable {}
extension Ibc_Core_Channel_V2_Payload: @unchecked Sendable {}
extension Ibc_Core_Channel_V2_Acknowledgement: @unchecked Sendable {}
extension Ibc_Core_Channel_V2_RecvPacketResult: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "ibc.core.channel.v2"

extension Ibc_Core_Channel_V2_PacketStatus: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "PACKET_STATUS_UNSPECIFIED"),
    1: .same(proto: "PACKET_STATUS_SUCCESS"),
    2: .same(proto: "PACKET_STATUS_FAILURE"),
    3: .same(proto: "PACKET_STATUS_ASYNC"),
  ]
}

extension Ibc_Core_Channel_V2_Packet: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Packet"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sequence"),
    2: .standard(proto: "source_client"),
    3: .standard(proto: "destination_client"),
    4: .standard(proto: "timeout_timestamp"),
    5: .same(proto: "payloads"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.sequence) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.sourceClient) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.destinationClient) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.timeoutTimestamp) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.payloads) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.sequence != 0 {
      try visitor.visitSingularUInt64Field(value: self.sequence, fieldNumber: 1)
    }
    if !self.sourceClient.isEmpty {
      try visitor.visitSingularStringField(value: self.sourceClient, fieldNumber: 2)
    }
    if !self.destinationClient.isEmpty {
      try visitor.visitSingularStringField(value: self.destinationClient, fieldNumber: 3)
    }
    if self.timeoutTimestamp != 0 {
      try visitor.visitSingularUInt64Field(value: self.timeoutTimestamp, fieldNumber: 4)
    }
    if !self.payloads.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.payloads, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ibc_Core_Channel_V2_Packet, rhs: Ibc_Core_Channel_V2_Packet) -> Bool {
    if lhs.sequence != rhs.sequence {return false}
    if lhs.sourceClient != rhs.sourceClient {return false}
    if lhs.destinationClient != rhs.destinationClient {return false}
    if lhs.timeoutTimestamp != rhs.timeoutTimestamp {return false}
    if lhs.payloads != rhs.payloads {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ibc_Core_Channel_V2_Payload: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Payload"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "source_port"),
    2: .standard(proto: "destination_port"),
    3: .same(proto: "version"),
    4: .same(proto: "encoding"),
    5: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.sourcePort) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.destinationPort) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.version) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.encoding) }()
      case 5: try { try decoder.decodeSingularBytesField(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sourcePort.isEmpty {
      try visitor.visitSingularStringField(value: self.sourcePort, fieldNumber: 1)
    }
    if !self.destinationPort.isEmpty {
      try visitor.visitSingularStringField(value: self.destinationPort, fieldNumber: 2)
    }
    if !self.version.isEmpty {
      try visitor.visitSingularStringField(value: self.version, fieldNumber: 3)
    }
    if !self.encoding.isEmpty {
      try visitor.visitSingularStringField(value: self.encoding, fieldNumber: 4)
    }
    if !self.value.isEmpty {
      try visitor.visitSingularBytesField(value: self.value, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ibc_Core_Channel_V2_Payload, rhs: Ibc_Core_Channel_V2_Payload) -> Bool {
    if lhs.sourcePort != rhs.sourcePort {return false}
    if lhs.destinationPort != rhs.destinationPort {return false}
    if lhs.version != rhs.version {return false}
    if lhs.encoding != rhs.encoding {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ibc_Core_Channel_V2_Acknowledgement: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Acknowledgement"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "app_acknowledgements"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedBytesField(value: &self.appAcknowledgements) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.appAcknowledgements.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.appAcknowledgements, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ibc_Core_Channel_V2_Acknowledgement, rhs: Ibc_Core_Channel_V2_Acknowledgement) -> Bool {
    if lhs.appAcknowledgements != rhs.appAcknowledgements {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ibc_Core_Channel_V2_RecvPacketResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RecvPacketResult"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .same(proto: "acknowledgement"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.acknowledgement) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.status != .unspecified {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 1)
    }
    if !self.acknowledgement.isEmpty {
      try visitor.visitSingularBytesField(value: self.acknowledgement, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ibc_Core_Channel_V2_RecvPacketResult, rhs: Ibc_Core_Channel_V2_RecvPacketResult) -> Bool {
    if lhs.status != rhs.status {return false}
    if lhs.acknowledgement != rhs.acknowledgement {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
