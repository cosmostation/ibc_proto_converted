// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: stratos/register/v1/event.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// EventCreateResourceNode is emitted on Msg/MsgCreateResourceNode
struct Stratos_Register_V1_EventCreateResourceNode {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sender: String = String()

  var networkAddress: String = String()

  var pubkey: String = String()

  var ozoneLimitChanges: String = String()

  var initialDeposit: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// EventCreateMetaNode is emitted on Msg/MsgCreateMetaNode
struct Stratos_Register_V1_EventCreateMetaNode {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sender: String = String()

  var networkAddress: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// EventUnBondingResourceNode is emitted on Msg/MsgRemoveResourceNode
struct Stratos_Register_V1_EventUnBondingResourceNode {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sender: String = String()

  var resourceNode: String = String()

  var depositToRemove: String = String()

  var unbondingMatureTime: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// EventUnBondingResourceNode is emitted on Msg/MsgRemoveMetaNode
struct Stratos_Register_V1_EventUnBondingMetaNode {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sender: String = String()

  var metaNode: String = String()

  var ozoneLimitChanges: String = String()

  var depositToRemove: String = String()

  var unbondingMatureTime: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// EventMetaNodeRegistrationVote is emitted on Msg/MsgMetaNodeRegistrationVote
struct Stratos_Register_V1_EventMetaNodeRegistrationVote {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sender: String = String()

  var voterNetworkAddress: String = String()

  var candidateNetworkAddress: String = String()

  var candidateStatus: String = String()

  var ozoneLimitChanges: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Stratos_Register_V1_EventKickMetaNodeVote {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sender: String = String()

  var voterNetworkAddress: String = String()

  var targetNetworkAddress: String = String()

  var targetStatus: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// EventUpdateResourceNode is emitted on Msg/MsgUpdateResourceNode
struct Stratos_Register_V1_EventUpdateResourceNode {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sender: String = String()

  var networkAddress: String = String()

  var beneficiaryAddress: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// EventUpdateResourceNodeDeposit is emitted on Msg/MsgUpdateResourceNodeDeposit
struct Stratos_Register_V1_EventUpdateResourceNodeDeposit {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sender: String = String()

  var networkAddress: String = String()

  var depositDelta: String = String()

  var currentDeposit: String = String()

  var availableTokenBefore: String = String()

  var availableTokenAfter: String = String()

  var ozoneLimitChanges: String = String()

  var unbondingMatureTime: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// EventUpdateEffectiveDeposit is emitted on Msg/MsgUpdateEffectiveDeposit
struct Stratos_Register_V1_EventUpdateEffectiveDeposit {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var networkAddress: String = String()

  var effectiveDepositAfter: String = String()

  var isUnsuspended: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// EventUpdateMetaNode is emitted on Msg/MsgUpdateMetaNode
struct Stratos_Register_V1_EventUpdateMetaNode {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sender: String = String()

  var networkAddress: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// EventUpdateMetaNodeDeposit is emitted on Msg/MsgUpdateMetaNodeDeposit
struct Stratos_Register_V1_EventUpdateMetaNodeDeposit {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sender: String = String()

  var networkAddress: String = String()

  var depositDelta: String = String()

  var currentDeposit: String = String()

  var availableTokenBefore: String = String()

  var availableTokenAfter: String = String()

  var ozoneLimitChanges: String = String()

  var unbondingMatureTime: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// EventCompleteUnBondingResourceNode is emitted on EndBlocker
struct Stratos_Register_V1_EventCompleteUnBondingResourceNode {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var amount: String = String()

  var networkAddress: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// EventCompleteUnBondingMetaNode is emitted on EndBlocker
struct Stratos_Register_V1_EventCompleteUnBondingMetaNode {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var amount: String = String()

  var networkAddress: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Stratos_Register_V1_EventCreateResourceNode: @unchecked Sendable {}
extension Stratos_Register_V1_EventCreateMetaNode: @unchecked Sendable {}
extension Stratos_Register_V1_EventUnBondingResourceNode: @unchecked Sendable {}
extension Stratos_Register_V1_EventUnBondingMetaNode: @unchecked Sendable {}
extension Stratos_Register_V1_EventMetaNodeRegistrationVote: @unchecked Sendable {}
extension Stratos_Register_V1_EventKickMetaNodeVote: @unchecked Sendable {}
extension Stratos_Register_V1_EventUpdateResourceNode: @unchecked Sendable {}
extension Stratos_Register_V1_EventUpdateResourceNodeDeposit: @unchecked Sendable {}
extension Stratos_Register_V1_EventUpdateEffectiveDeposit: @unchecked Sendable {}
extension Stratos_Register_V1_EventUpdateMetaNode: @unchecked Sendable {}
extension Stratos_Register_V1_EventUpdateMetaNodeDeposit: @unchecked Sendable {}
extension Stratos_Register_V1_EventCompleteUnBondingResourceNode: @unchecked Sendable {}
extension Stratos_Register_V1_EventCompleteUnBondingMetaNode: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "stratos.register.v1"

extension Stratos_Register_V1_EventCreateResourceNode: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventCreateResourceNode"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sender"),
    2: .standard(proto: "network_address"),
    3: .same(proto: "pubkey"),
    4: .standard(proto: "ozone_limit_changes"),
    5: .standard(proto: "initial_deposit"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.sender) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.networkAddress) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.pubkey) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.ozoneLimitChanges) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.initialDeposit) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sender.isEmpty {
      try visitor.visitSingularStringField(value: self.sender, fieldNumber: 1)
    }
    if !self.networkAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.networkAddress, fieldNumber: 2)
    }
    if !self.pubkey.isEmpty {
      try visitor.visitSingularStringField(value: self.pubkey, fieldNumber: 3)
    }
    if !self.ozoneLimitChanges.isEmpty {
      try visitor.visitSingularStringField(value: self.ozoneLimitChanges, fieldNumber: 4)
    }
    if !self.initialDeposit.isEmpty {
      try visitor.visitSingularStringField(value: self.initialDeposit, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stratos_Register_V1_EventCreateResourceNode, rhs: Stratos_Register_V1_EventCreateResourceNode) -> Bool {
    if lhs.sender != rhs.sender {return false}
    if lhs.networkAddress != rhs.networkAddress {return false}
    if lhs.pubkey != rhs.pubkey {return false}
    if lhs.ozoneLimitChanges != rhs.ozoneLimitChanges {return false}
    if lhs.initialDeposit != rhs.initialDeposit {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stratos_Register_V1_EventCreateMetaNode: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventCreateMetaNode"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sender"),
    2: .standard(proto: "network_address"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.sender) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.networkAddress) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sender.isEmpty {
      try visitor.visitSingularStringField(value: self.sender, fieldNumber: 1)
    }
    if !self.networkAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.networkAddress, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stratos_Register_V1_EventCreateMetaNode, rhs: Stratos_Register_V1_EventCreateMetaNode) -> Bool {
    if lhs.sender != rhs.sender {return false}
    if lhs.networkAddress != rhs.networkAddress {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stratos_Register_V1_EventUnBondingResourceNode: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventUnBondingResourceNode"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sender"),
    2: .standard(proto: "resource_node"),
    3: .standard(proto: "deposit_to_remove"),
    4: .standard(proto: "unbonding_mature_time"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.sender) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.resourceNode) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.depositToRemove) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.unbondingMatureTime) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sender.isEmpty {
      try visitor.visitSingularStringField(value: self.sender, fieldNumber: 1)
    }
    if !self.resourceNode.isEmpty {
      try visitor.visitSingularStringField(value: self.resourceNode, fieldNumber: 2)
    }
    if !self.depositToRemove.isEmpty {
      try visitor.visitSingularStringField(value: self.depositToRemove, fieldNumber: 3)
    }
    if !self.unbondingMatureTime.isEmpty {
      try visitor.visitSingularStringField(value: self.unbondingMatureTime, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stratos_Register_V1_EventUnBondingResourceNode, rhs: Stratos_Register_V1_EventUnBondingResourceNode) -> Bool {
    if lhs.sender != rhs.sender {return false}
    if lhs.resourceNode != rhs.resourceNode {return false}
    if lhs.depositToRemove != rhs.depositToRemove {return false}
    if lhs.unbondingMatureTime != rhs.unbondingMatureTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stratos_Register_V1_EventUnBondingMetaNode: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventUnBondingMetaNode"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sender"),
    2: .standard(proto: "meta_node"),
    3: .standard(proto: "ozone_limit_changes"),
    4: .standard(proto: "deposit_to_remove"),
    5: .standard(proto: "unbonding_mature_time"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.sender) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.metaNode) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.ozoneLimitChanges) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.depositToRemove) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.unbondingMatureTime) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sender.isEmpty {
      try visitor.visitSingularStringField(value: self.sender, fieldNumber: 1)
    }
    if !self.metaNode.isEmpty {
      try visitor.visitSingularStringField(value: self.metaNode, fieldNumber: 2)
    }
    if !self.ozoneLimitChanges.isEmpty {
      try visitor.visitSingularStringField(value: self.ozoneLimitChanges, fieldNumber: 3)
    }
    if !self.depositToRemove.isEmpty {
      try visitor.visitSingularStringField(value: self.depositToRemove, fieldNumber: 4)
    }
    if !self.unbondingMatureTime.isEmpty {
      try visitor.visitSingularStringField(value: self.unbondingMatureTime, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stratos_Register_V1_EventUnBondingMetaNode, rhs: Stratos_Register_V1_EventUnBondingMetaNode) -> Bool {
    if lhs.sender != rhs.sender {return false}
    if lhs.metaNode != rhs.metaNode {return false}
    if lhs.ozoneLimitChanges != rhs.ozoneLimitChanges {return false}
    if lhs.depositToRemove != rhs.depositToRemove {return false}
    if lhs.unbondingMatureTime != rhs.unbondingMatureTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stratos_Register_V1_EventMetaNodeRegistrationVote: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventMetaNodeRegistrationVote"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sender"),
    2: .standard(proto: "voter_network_address"),
    3: .standard(proto: "candidate_network_address"),
    4: .standard(proto: "candidate_status"),
    5: .standard(proto: "ozone_limit_changes"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.sender) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.voterNetworkAddress) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.candidateNetworkAddress) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.candidateStatus) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.ozoneLimitChanges) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sender.isEmpty {
      try visitor.visitSingularStringField(value: self.sender, fieldNumber: 1)
    }
    if !self.voterNetworkAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.voterNetworkAddress, fieldNumber: 2)
    }
    if !self.candidateNetworkAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.candidateNetworkAddress, fieldNumber: 3)
    }
    if !self.candidateStatus.isEmpty {
      try visitor.visitSingularStringField(value: self.candidateStatus, fieldNumber: 4)
    }
    if !self.ozoneLimitChanges.isEmpty {
      try visitor.visitSingularStringField(value: self.ozoneLimitChanges, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stratos_Register_V1_EventMetaNodeRegistrationVote, rhs: Stratos_Register_V1_EventMetaNodeRegistrationVote) -> Bool {
    if lhs.sender != rhs.sender {return false}
    if lhs.voterNetworkAddress != rhs.voterNetworkAddress {return false}
    if lhs.candidateNetworkAddress != rhs.candidateNetworkAddress {return false}
    if lhs.candidateStatus != rhs.candidateStatus {return false}
    if lhs.ozoneLimitChanges != rhs.ozoneLimitChanges {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stratos_Register_V1_EventKickMetaNodeVote: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventKickMetaNodeVote"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sender"),
    2: .standard(proto: "voter_network_address"),
    3: .standard(proto: "target_network_address"),
    4: .standard(proto: "target_status"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.sender) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.voterNetworkAddress) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.targetNetworkAddress) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.targetStatus) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sender.isEmpty {
      try visitor.visitSingularStringField(value: self.sender, fieldNumber: 1)
    }
    if !self.voterNetworkAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.voterNetworkAddress, fieldNumber: 2)
    }
    if !self.targetNetworkAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.targetNetworkAddress, fieldNumber: 3)
    }
    if !self.targetStatus.isEmpty {
      try visitor.visitSingularStringField(value: self.targetStatus, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stratos_Register_V1_EventKickMetaNodeVote, rhs: Stratos_Register_V1_EventKickMetaNodeVote) -> Bool {
    if lhs.sender != rhs.sender {return false}
    if lhs.voterNetworkAddress != rhs.voterNetworkAddress {return false}
    if lhs.targetNetworkAddress != rhs.targetNetworkAddress {return false}
    if lhs.targetStatus != rhs.targetStatus {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stratos_Register_V1_EventUpdateResourceNode: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventUpdateResourceNode"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sender"),
    2: .standard(proto: "network_address"),
    3: .standard(proto: "beneficiary_address"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.sender) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.networkAddress) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.beneficiaryAddress) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sender.isEmpty {
      try visitor.visitSingularStringField(value: self.sender, fieldNumber: 1)
    }
    if !self.networkAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.networkAddress, fieldNumber: 2)
    }
    if !self.beneficiaryAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.beneficiaryAddress, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stratos_Register_V1_EventUpdateResourceNode, rhs: Stratos_Register_V1_EventUpdateResourceNode) -> Bool {
    if lhs.sender != rhs.sender {return false}
    if lhs.networkAddress != rhs.networkAddress {return false}
    if lhs.beneficiaryAddress != rhs.beneficiaryAddress {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stratos_Register_V1_EventUpdateResourceNodeDeposit: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventUpdateResourceNodeDeposit"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sender"),
    2: .standard(proto: "network_address"),
    3: .standard(proto: "deposit_delta"),
    4: .standard(proto: "current_deposit"),
    5: .standard(proto: "available_token_before"),
    6: .standard(proto: "available_token_after"),
    7: .standard(proto: "ozone_limit_changes"),
    8: .standard(proto: "unbonding_mature_time"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.sender) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.networkAddress) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.depositDelta) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.currentDeposit) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.availableTokenBefore) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.availableTokenAfter) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.ozoneLimitChanges) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.unbondingMatureTime) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sender.isEmpty {
      try visitor.visitSingularStringField(value: self.sender, fieldNumber: 1)
    }
    if !self.networkAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.networkAddress, fieldNumber: 2)
    }
    if !self.depositDelta.isEmpty {
      try visitor.visitSingularStringField(value: self.depositDelta, fieldNumber: 3)
    }
    if !self.currentDeposit.isEmpty {
      try visitor.visitSingularStringField(value: self.currentDeposit, fieldNumber: 4)
    }
    if !self.availableTokenBefore.isEmpty {
      try visitor.visitSingularStringField(value: self.availableTokenBefore, fieldNumber: 5)
    }
    if !self.availableTokenAfter.isEmpty {
      try visitor.visitSingularStringField(value: self.availableTokenAfter, fieldNumber: 6)
    }
    if !self.ozoneLimitChanges.isEmpty {
      try visitor.visitSingularStringField(value: self.ozoneLimitChanges, fieldNumber: 7)
    }
    if !self.unbondingMatureTime.isEmpty {
      try visitor.visitSingularStringField(value: self.unbondingMatureTime, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stratos_Register_V1_EventUpdateResourceNodeDeposit, rhs: Stratos_Register_V1_EventUpdateResourceNodeDeposit) -> Bool {
    if lhs.sender != rhs.sender {return false}
    if lhs.networkAddress != rhs.networkAddress {return false}
    if lhs.depositDelta != rhs.depositDelta {return false}
    if lhs.currentDeposit != rhs.currentDeposit {return false}
    if lhs.availableTokenBefore != rhs.availableTokenBefore {return false}
    if lhs.availableTokenAfter != rhs.availableTokenAfter {return false}
    if lhs.ozoneLimitChanges != rhs.ozoneLimitChanges {return false}
    if lhs.unbondingMatureTime != rhs.unbondingMatureTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stratos_Register_V1_EventUpdateEffectiveDeposit: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventUpdateEffectiveDeposit"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "network_address"),
    2: .standard(proto: "effective_deposit_after"),
    3: .standard(proto: "is_unsuspended"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.networkAddress) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.effectiveDepositAfter) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.isUnsuspended) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.networkAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.networkAddress, fieldNumber: 1)
    }
    if !self.effectiveDepositAfter.isEmpty {
      try visitor.visitSingularStringField(value: self.effectiveDepositAfter, fieldNumber: 2)
    }
    if !self.isUnsuspended.isEmpty {
      try visitor.visitSingularStringField(value: self.isUnsuspended, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stratos_Register_V1_EventUpdateEffectiveDeposit, rhs: Stratos_Register_V1_EventUpdateEffectiveDeposit) -> Bool {
    if lhs.networkAddress != rhs.networkAddress {return false}
    if lhs.effectiveDepositAfter != rhs.effectiveDepositAfter {return false}
    if lhs.isUnsuspended != rhs.isUnsuspended {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stratos_Register_V1_EventUpdateMetaNode: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventUpdateMetaNode"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sender"),
    2: .standard(proto: "network_address"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.sender) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.networkAddress) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sender.isEmpty {
      try visitor.visitSingularStringField(value: self.sender, fieldNumber: 1)
    }
    if !self.networkAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.networkAddress, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stratos_Register_V1_EventUpdateMetaNode, rhs: Stratos_Register_V1_EventUpdateMetaNode) -> Bool {
    if lhs.sender != rhs.sender {return false}
    if lhs.networkAddress != rhs.networkAddress {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stratos_Register_V1_EventUpdateMetaNodeDeposit: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventUpdateMetaNodeDeposit"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sender"),
    2: .standard(proto: "network_address"),
    3: .standard(proto: "deposit_delta"),
    4: .standard(proto: "current_deposit"),
    5: .standard(proto: "available_token_before"),
    6: .standard(proto: "available_token_after"),
    7: .standard(proto: "ozone_limit_changes"),
    8: .standard(proto: "unbonding_mature_time"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.sender) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.networkAddress) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.depositDelta) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.currentDeposit) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.availableTokenBefore) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.availableTokenAfter) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.ozoneLimitChanges) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.unbondingMatureTime) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sender.isEmpty {
      try visitor.visitSingularStringField(value: self.sender, fieldNumber: 1)
    }
    if !self.networkAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.networkAddress, fieldNumber: 2)
    }
    if !self.depositDelta.isEmpty {
      try visitor.visitSingularStringField(value: self.depositDelta, fieldNumber: 3)
    }
    if !self.currentDeposit.isEmpty {
      try visitor.visitSingularStringField(value: self.currentDeposit, fieldNumber: 4)
    }
    if !self.availableTokenBefore.isEmpty {
      try visitor.visitSingularStringField(value: self.availableTokenBefore, fieldNumber: 5)
    }
    if !self.availableTokenAfter.isEmpty {
      try visitor.visitSingularStringField(value: self.availableTokenAfter, fieldNumber: 6)
    }
    if !self.ozoneLimitChanges.isEmpty {
      try visitor.visitSingularStringField(value: self.ozoneLimitChanges, fieldNumber: 7)
    }
    if !self.unbondingMatureTime.isEmpty {
      try visitor.visitSingularStringField(value: self.unbondingMatureTime, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stratos_Register_V1_EventUpdateMetaNodeDeposit, rhs: Stratos_Register_V1_EventUpdateMetaNodeDeposit) -> Bool {
    if lhs.sender != rhs.sender {return false}
    if lhs.networkAddress != rhs.networkAddress {return false}
    if lhs.depositDelta != rhs.depositDelta {return false}
    if lhs.currentDeposit != rhs.currentDeposit {return false}
    if lhs.availableTokenBefore != rhs.availableTokenBefore {return false}
    if lhs.availableTokenAfter != rhs.availableTokenAfter {return false}
    if lhs.ozoneLimitChanges != rhs.ozoneLimitChanges {return false}
    if lhs.unbondingMatureTime != rhs.unbondingMatureTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stratos_Register_V1_EventCompleteUnBondingResourceNode: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventCompleteUnBondingResourceNode"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "amount"),
    2: .standard(proto: "network_address"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.amount) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.networkAddress) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.amount.isEmpty {
      try visitor.visitSingularStringField(value: self.amount, fieldNumber: 1)
    }
    if !self.networkAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.networkAddress, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stratos_Register_V1_EventCompleteUnBondingResourceNode, rhs: Stratos_Register_V1_EventCompleteUnBondingResourceNode) -> Bool {
    if lhs.amount != rhs.amount {return false}
    if lhs.networkAddress != rhs.networkAddress {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stratos_Register_V1_EventCompleteUnBondingMetaNode: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventCompleteUnBondingMetaNode"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "amount"),
    2: .standard(proto: "network_address"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.amount) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.networkAddress) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.amount.isEmpty {
      try visitor.visitSingularStringField(value: self.amount, fieldNumber: 1)
    }
    if !self.networkAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.networkAddress, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stratos_Register_V1_EventCompleteUnBondingMetaNode, rhs: Stratos_Register_V1_EventCompleteUnBondingMetaNode) -> Bool {
    if lhs.amount != rhs.amount {return false}
    if lhs.networkAddress != rhs.networkAddress {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
