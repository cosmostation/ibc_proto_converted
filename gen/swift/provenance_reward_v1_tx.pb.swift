// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: provenance/reward/v1/tx.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// MsgCreateRewardProgramRequest is the request type for creating a reward program RPC
struct Provenance_Reward_V1_MsgCreateRewardProgramRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// title for the reward program.
  var title: String = String()

  /// description for the reward program.
  var description_p: String = String()

  /// provider address for the reward program funds and signer of message.
  var distributeFromAddress: String = String()

  /// total reward pool for the reward program.
  var totalRewardPool: Cosmos_Base_V1beta1_Coin {
    get {return _totalRewardPool ?? Cosmos_Base_V1beta1_Coin()}
    set {_totalRewardPool = newValue}
  }
  /// Returns true if `totalRewardPool` has been explicitly set.
  var hasTotalRewardPool: Bool {return self._totalRewardPool != nil}
  /// Clears the value of `totalRewardPool`. Subsequent reads from it will return its default value.
  mutating func clearTotalRewardPool() {self._totalRewardPool = nil}

  /// maximum amount of funds an address can be rewarded per claim period.
  var maxRewardPerClaimAddress: Cosmos_Base_V1beta1_Coin {
    get {return _maxRewardPerClaimAddress ?? Cosmos_Base_V1beta1_Coin()}
    set {_maxRewardPerClaimAddress = newValue}
  }
  /// Returns true if `maxRewardPerClaimAddress` has been explicitly set.
  var hasMaxRewardPerClaimAddress: Bool {return self._maxRewardPerClaimAddress != nil}
  /// Clears the value of `maxRewardPerClaimAddress`. Subsequent reads from it will return its default value.
  mutating func clearMaxRewardPerClaimAddress() {self._maxRewardPerClaimAddress = nil}

  /// start time of the reward program.
  var programStartTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _programStartTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_programStartTime = newValue}
  }
  /// Returns true if `programStartTime` has been explicitly set.
  var hasProgramStartTime: Bool {return self._programStartTime != nil}
  /// Clears the value of `programStartTime`. Subsequent reads from it will return its default value.
  mutating func clearProgramStartTime() {self._programStartTime = nil}

  /// number of claim periods the reward program runs for.
  var claimPeriods: UInt64 = 0

  /// number of days a claim period will exist.
  var claimPeriodDays: UInt64 = 0

  /// maximum number of claim periods a reward program can rollover.
  var maxRolloverClaimPeriods: UInt64 = 0

  /// number of days before a reward program will expire after it has ended.
  var expireDays: UInt64 = 0

  /// actions that count towards the reward.
  var qualifyingActions: [Provenance_Reward_V1_QualifyingAction] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _totalRewardPool: Cosmos_Base_V1beta1_Coin? = nil
  fileprivate var _maxRewardPerClaimAddress: Cosmos_Base_V1beta1_Coin? = nil
  fileprivate var _programStartTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// MsgCreateRewardProgramResponse is the response type for creating a reward program RPC
struct Provenance_Reward_V1_MsgCreateRewardProgramResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// reward program id that is generated on creation.
  var id: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgEndRewardProgramRequest is the request type for ending a reward program RPC
struct Provenance_Reward_V1_MsgEndRewardProgramRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// reward program id to end.
  var rewardProgramID: UInt64 = 0

  /// owner of the reward program that funds were distributed from.
  var programOwnerAddress: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgEndRewardProgramResponse is the response type for ending a reward program RPC
struct Provenance_Reward_V1_MsgEndRewardProgramResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgClaimRewardsRequest is the request type for claiming reward from reward program RPC
struct Provenance_Reward_V1_MsgClaimRewardsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// reward program id to claim rewards.
  var rewardProgramID: UInt64 = 0

  /// reward address and signer of msg to send claimed rewards to.
  var rewardAddress: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgClaimRewardsResponse is the response type for claiming reward from reward program RPC
struct Provenance_Reward_V1_MsgClaimRewardsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// details about acquired rewards from reward program.
  var claimDetails: Provenance_Reward_V1_RewardProgramClaimDetail {
    get {return _claimDetails ?? Provenance_Reward_V1_RewardProgramClaimDetail()}
    set {_claimDetails = newValue}
  }
  /// Returns true if `claimDetails` has been explicitly set.
  var hasClaimDetails: Bool {return self._claimDetails != nil}
  /// Clears the value of `claimDetails`. Subsequent reads from it will return its default value.
  mutating func clearClaimDetails() {self._claimDetails = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _claimDetails: Provenance_Reward_V1_RewardProgramClaimDetail? = nil
}

/// MsgClaimRewardsResponse is the request type for claiming rewards from all reward programs RPC
struct Provenance_Reward_V1_MsgClaimAllRewardsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// reward address and signer of msg to send claimed rewards to.
  var rewardAddress: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgClaimRewardsResponse is the response type for claiming rewards from all reward programs RPC
struct Provenance_Reward_V1_MsgClaimAllRewardsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// total rewards claimed for all eligible claim periods in all programs.
  var totalRewardClaim: [Cosmos_Base_V1beta1_Coin] = []

  /// details about acquired rewards from a reward program.
  var claimDetails: [Provenance_Reward_V1_RewardProgramClaimDetail] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// ClaimedRewardPeriodDetail is information regarding an addresses' shares and reward for a claim period.
struct Provenance_Reward_V1_ClaimedRewardPeriodDetail {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// claim period id
  var claimPeriodID: UInt64 = 0

  /// total shares accumulated for claim period
  var totalShares: UInt64 = 0

  /// total rewards for claim period
  var claimPeriodReward: Cosmos_Base_V1beta1_Coin {
    get {return _claimPeriodReward ?? Cosmos_Base_V1beta1_Coin()}
    set {_claimPeriodReward = newValue}
  }
  /// Returns true if `claimPeriodReward` has been explicitly set.
  var hasClaimPeriodReward: Bool {return self._claimPeriodReward != nil}
  /// Clears the value of `claimPeriodReward`. Subsequent reads from it will return its default value.
  mutating func clearClaimPeriodReward() {self._claimPeriodReward = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _claimPeriodReward: Cosmos_Base_V1beta1_Coin? = nil
}

/// RewardProgramClaimDetail is the response object regarding an address's shares and reward for a reward program.
struct Provenance_Reward_V1_RewardProgramClaimDetail {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// reward program id.
  var rewardProgramID: UInt64 = 0

  /// total rewards claimed for all eligible claim periods in program.
  var totalRewardClaim: Cosmos_Base_V1beta1_Coin {
    get {return _totalRewardClaim ?? Cosmos_Base_V1beta1_Coin()}
    set {_totalRewardClaim = newValue}
  }
  /// Returns true if `totalRewardClaim` has been explicitly set.
  var hasTotalRewardClaim: Bool {return self._totalRewardClaim != nil}
  /// Clears the value of `totalRewardClaim`. Subsequent reads from it will return its default value.
  mutating func clearTotalRewardClaim() {self._totalRewardClaim = nil}

  /// claim period details.
  var claimedRewardPeriodDetails: [Provenance_Reward_V1_ClaimedRewardPeriodDetail] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _totalRewardClaim: Cosmos_Base_V1beta1_Coin? = nil
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Provenance_Reward_V1_MsgCreateRewardProgramRequest: @unchecked Sendable {}
extension Provenance_Reward_V1_MsgCreateRewardProgramResponse: @unchecked Sendable {}
extension Provenance_Reward_V1_MsgEndRewardProgramRequest: @unchecked Sendable {}
extension Provenance_Reward_V1_MsgEndRewardProgramResponse: @unchecked Sendable {}
extension Provenance_Reward_V1_MsgClaimRewardsRequest: @unchecked Sendable {}
extension Provenance_Reward_V1_MsgClaimRewardsResponse: @unchecked Sendable {}
extension Provenance_Reward_V1_MsgClaimAllRewardsRequest: @unchecked Sendable {}
extension Provenance_Reward_V1_MsgClaimAllRewardsResponse: @unchecked Sendable {}
extension Provenance_Reward_V1_ClaimedRewardPeriodDetail: @unchecked Sendable {}
extension Provenance_Reward_V1_RewardProgramClaimDetail: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "provenance.reward.v1"

extension Provenance_Reward_V1_MsgCreateRewardProgramRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgCreateRewardProgramRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "title"),
    2: .same(proto: "description"),
    3: .standard(proto: "distribute_from_address"),
    4: .standard(proto: "total_reward_pool"),
    5: .standard(proto: "max_reward_per_claim_address"),
    6: .standard(proto: "program_start_time"),
    7: .standard(proto: "claim_periods"),
    8: .standard(proto: "claim_period_days"),
    9: .standard(proto: "max_rollover_claim_periods"),
    10: .standard(proto: "expire_days"),
    11: .standard(proto: "qualifying_actions"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.distributeFromAddress) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._totalRewardPool) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._maxRewardPerClaimAddress) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._programStartTime) }()
      case 7: try { try decoder.decodeSingularUInt64Field(value: &self.claimPeriods) }()
      case 8: try { try decoder.decodeSingularUInt64Field(value: &self.claimPeriodDays) }()
      case 9: try { try decoder.decodeSingularUInt64Field(value: &self.maxRolloverClaimPeriods) }()
      case 10: try { try decoder.decodeSingularUInt64Field(value: &self.expireDays) }()
      case 11: try { try decoder.decodeRepeatedMessageField(value: &self.qualifyingActions) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    if !self.distributeFromAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.distributeFromAddress, fieldNumber: 3)
    }
    try { if let v = self._totalRewardPool {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._maxRewardPerClaimAddress {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._programStartTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    if self.claimPeriods != 0 {
      try visitor.visitSingularUInt64Field(value: self.claimPeriods, fieldNumber: 7)
    }
    if self.claimPeriodDays != 0 {
      try visitor.visitSingularUInt64Field(value: self.claimPeriodDays, fieldNumber: 8)
    }
    if self.maxRolloverClaimPeriods != 0 {
      try visitor.visitSingularUInt64Field(value: self.maxRolloverClaimPeriods, fieldNumber: 9)
    }
    if self.expireDays != 0 {
      try visitor.visitSingularUInt64Field(value: self.expireDays, fieldNumber: 10)
    }
    if !self.qualifyingActions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.qualifyingActions, fieldNumber: 11)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Reward_V1_MsgCreateRewardProgramRequest, rhs: Provenance_Reward_V1_MsgCreateRewardProgramRequest) -> Bool {
    if lhs.title != rhs.title {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.distributeFromAddress != rhs.distributeFromAddress {return false}
    if lhs._totalRewardPool != rhs._totalRewardPool {return false}
    if lhs._maxRewardPerClaimAddress != rhs._maxRewardPerClaimAddress {return false}
    if lhs._programStartTime != rhs._programStartTime {return false}
    if lhs.claimPeriods != rhs.claimPeriods {return false}
    if lhs.claimPeriodDays != rhs.claimPeriodDays {return false}
    if lhs.maxRolloverClaimPeriods != rhs.maxRolloverClaimPeriods {return false}
    if lhs.expireDays != rhs.expireDays {return false}
    if lhs.qualifyingActions != rhs.qualifyingActions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Reward_V1_MsgCreateRewardProgramResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgCreateRewardProgramResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.id) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularUInt64Field(value: self.id, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Reward_V1_MsgCreateRewardProgramResponse, rhs: Provenance_Reward_V1_MsgCreateRewardProgramResponse) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Reward_V1_MsgEndRewardProgramRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgEndRewardProgramRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "reward_program_id"),
    2: .standard(proto: "program_owner_address"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.rewardProgramID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.programOwnerAddress) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.rewardProgramID != 0 {
      try visitor.visitSingularUInt64Field(value: self.rewardProgramID, fieldNumber: 1)
    }
    if !self.programOwnerAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.programOwnerAddress, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Reward_V1_MsgEndRewardProgramRequest, rhs: Provenance_Reward_V1_MsgEndRewardProgramRequest) -> Bool {
    if lhs.rewardProgramID != rhs.rewardProgramID {return false}
    if lhs.programOwnerAddress != rhs.programOwnerAddress {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Reward_V1_MsgEndRewardProgramResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgEndRewardProgramResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Reward_V1_MsgEndRewardProgramResponse, rhs: Provenance_Reward_V1_MsgEndRewardProgramResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Reward_V1_MsgClaimRewardsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgClaimRewardsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "reward_program_id"),
    2: .standard(proto: "reward_address"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.rewardProgramID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.rewardAddress) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.rewardProgramID != 0 {
      try visitor.visitSingularUInt64Field(value: self.rewardProgramID, fieldNumber: 1)
    }
    if !self.rewardAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.rewardAddress, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Reward_V1_MsgClaimRewardsRequest, rhs: Provenance_Reward_V1_MsgClaimRewardsRequest) -> Bool {
    if lhs.rewardProgramID != rhs.rewardProgramID {return false}
    if lhs.rewardAddress != rhs.rewardAddress {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Reward_V1_MsgClaimRewardsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgClaimRewardsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "claim_details"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._claimDetails) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._claimDetails {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Reward_V1_MsgClaimRewardsResponse, rhs: Provenance_Reward_V1_MsgClaimRewardsResponse) -> Bool {
    if lhs._claimDetails != rhs._claimDetails {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Reward_V1_MsgClaimAllRewardsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgClaimAllRewardsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "reward_address"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.rewardAddress) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.rewardAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.rewardAddress, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Reward_V1_MsgClaimAllRewardsRequest, rhs: Provenance_Reward_V1_MsgClaimAllRewardsRequest) -> Bool {
    if lhs.rewardAddress != rhs.rewardAddress {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Reward_V1_MsgClaimAllRewardsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgClaimAllRewardsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "total_reward_claim"),
    2: .standard(proto: "claim_details"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.totalRewardClaim) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.claimDetails) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.totalRewardClaim.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.totalRewardClaim, fieldNumber: 1)
    }
    if !self.claimDetails.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.claimDetails, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Reward_V1_MsgClaimAllRewardsResponse, rhs: Provenance_Reward_V1_MsgClaimAllRewardsResponse) -> Bool {
    if lhs.totalRewardClaim != rhs.totalRewardClaim {return false}
    if lhs.claimDetails != rhs.claimDetails {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Reward_V1_ClaimedRewardPeriodDetail: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ClaimedRewardPeriodDetail"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "claim_period_id"),
    2: .standard(proto: "total_shares"),
    3: .standard(proto: "claim_period_reward"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.claimPeriodID) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.totalShares) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._claimPeriodReward) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.claimPeriodID != 0 {
      try visitor.visitSingularUInt64Field(value: self.claimPeriodID, fieldNumber: 1)
    }
    if self.totalShares != 0 {
      try visitor.visitSingularUInt64Field(value: self.totalShares, fieldNumber: 2)
    }
    try { if let v = self._claimPeriodReward {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Reward_V1_ClaimedRewardPeriodDetail, rhs: Provenance_Reward_V1_ClaimedRewardPeriodDetail) -> Bool {
    if lhs.claimPeriodID != rhs.claimPeriodID {return false}
    if lhs.totalShares != rhs.totalShares {return false}
    if lhs._claimPeriodReward != rhs._claimPeriodReward {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Reward_V1_RewardProgramClaimDetail: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RewardProgramClaimDetail"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "reward_program_id"),
    2: .standard(proto: "total_reward_claim"),
    3: .standard(proto: "claimed_reward_period_details"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.rewardProgramID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._totalRewardClaim) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.claimedRewardPeriodDetails) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.rewardProgramID != 0 {
      try visitor.visitSingularUInt64Field(value: self.rewardProgramID, fieldNumber: 1)
    }
    try { if let v = self._totalRewardClaim {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.claimedRewardPeriodDetails.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.claimedRewardPeriodDetails, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Reward_V1_RewardProgramClaimDetail, rhs: Provenance_Reward_V1_RewardProgramClaimDetail) -> Bool {
    if lhs.rewardProgramID != rhs.rewardProgramID {return false}
    if lhs._totalRewardClaim != rhs._totalRewardClaim {return false}
    if lhs.claimedRewardPeriodDetails != rhs.claimedRewardPeriodDetails {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
