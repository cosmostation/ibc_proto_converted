// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: provenance/reward/v1/reward.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// RewardProgram
struct Provenance_Reward_V1_RewardProgram {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// An integer to uniquely identify the reward program.
  var id: UInt64 {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  /// Name to help identify the Reward Program.(MaxTitleLength=140)
  var title: String {
    get {return _storage._title}
    set {_uniqueStorage()._title = newValue}
  }

  /// Short summary describing the Reward Program.(MaxDescriptionLength=10000)
  var description_p: String {
    get {return _storage._description_p}
    set {_uniqueStorage()._description_p = newValue}
  }

  /// address that provides funds for the total reward pool.
  var distributeFromAddress: String {
    get {return _storage._distributeFromAddress}
    set {_uniqueStorage()._distributeFromAddress = newValue}
  }

  /// The total amount of funding given to the RewardProgram.
  var totalRewardPool: Cosmos_Base_V1beta1_Coin {
    get {return _storage._totalRewardPool ?? Cosmos_Base_V1beta1_Coin()}
    set {_uniqueStorage()._totalRewardPool = newValue}
  }
  /// Returns true if `totalRewardPool` has been explicitly set.
  var hasTotalRewardPool: Bool {return _storage._totalRewardPool != nil}
  /// Clears the value of `totalRewardPool`. Subsequent reads from it will return its default value.
  mutating func clearTotalRewardPool() {_uniqueStorage()._totalRewardPool = nil}

  /// The remaining funds available to distribute after n claim periods have passed.
  var remainingPoolBalance: Cosmos_Base_V1beta1_Coin {
    get {return _storage._remainingPoolBalance ?? Cosmos_Base_V1beta1_Coin()}
    set {_uniqueStorage()._remainingPoolBalance = newValue}
  }
  /// Returns true if `remainingPoolBalance` has been explicitly set.
  var hasRemainingPoolBalance: Bool {return _storage._remainingPoolBalance != nil}
  /// Clears the value of `remainingPoolBalance`. Subsequent reads from it will return its default value.
  mutating func clearRemainingPoolBalance() {_uniqueStorage()._remainingPoolBalance = nil}

  /// The total amount of all funds claimed by participants for all past claim periods.
  var claimedAmount: Cosmos_Base_V1beta1_Coin {
    get {return _storage._claimedAmount ?? Cosmos_Base_V1beta1_Coin()}
    set {_uniqueStorage()._claimedAmount = newValue}
  }
  /// Returns true if `claimedAmount` has been explicitly set.
  var hasClaimedAmount: Bool {return _storage._claimedAmount != nil}
  /// Clears the value of `claimedAmount`. Subsequent reads from it will return its default value.
  mutating func clearClaimedAmount() {_uniqueStorage()._claimedAmount = nil}

  /// Maximum reward per claim period per address.
  var maxRewardByAddress: Cosmos_Base_V1beta1_Coin {
    get {return _storage._maxRewardByAddress ?? Cosmos_Base_V1beta1_Coin()}
    set {_uniqueStorage()._maxRewardByAddress = newValue}
  }
  /// Returns true if `maxRewardByAddress` has been explicitly set.
  var hasMaxRewardByAddress: Bool {return _storage._maxRewardByAddress != nil}
  /// Clears the value of `maxRewardByAddress`. Subsequent reads from it will return its default value.
  mutating func clearMaxRewardByAddress() {_uniqueStorage()._maxRewardByAddress = nil}

  /// Minimum amount of coins for a program to rollover.
  var minimumRolloverAmount: Cosmos_Base_V1beta1_Coin {
    get {return _storage._minimumRolloverAmount ?? Cosmos_Base_V1beta1_Coin()}
    set {_uniqueStorage()._minimumRolloverAmount = newValue}
  }
  /// Returns true if `minimumRolloverAmount` has been explicitly set.
  var hasMinimumRolloverAmount: Bool {return _storage._minimumRolloverAmount != nil}
  /// Clears the value of `minimumRolloverAmount`. Subsequent reads from it will return its default value.
  mutating func clearMinimumRolloverAmount() {_uniqueStorage()._minimumRolloverAmount = nil}

  /// Number of seconds that a claim period lasts.
  var claimPeriodSeconds: UInt64 {
    get {return _storage._claimPeriodSeconds}
    set {_uniqueStorage()._claimPeriodSeconds = newValue}
  }

  /// Time that a RewardProgram should start and switch to STARTED state.
  var programStartTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._programStartTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._programStartTime = newValue}
  }
  /// Returns true if `programStartTime` has been explicitly set.
  var hasProgramStartTime: Bool {return _storage._programStartTime != nil}
  /// Clears the value of `programStartTime`. Subsequent reads from it will return its default value.
  mutating func clearProgramStartTime() {_uniqueStorage()._programStartTime = nil}

  /// Time that a RewardProgram is expected to end, based on data when it was setup.
  var expectedProgramEndTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._expectedProgramEndTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._expectedProgramEndTime = newValue}
  }
  /// Returns true if `expectedProgramEndTime` has been explicitly set.
  var hasExpectedProgramEndTime: Bool {return _storage._expectedProgramEndTime != nil}
  /// Clears the value of `expectedProgramEndTime`. Subsequent reads from it will return its default value.
  mutating func clearExpectedProgramEndTime() {_uniqueStorage()._expectedProgramEndTime = nil}

  /// Time that a RewardProgram MUST end.
  var programEndTimeMax: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._programEndTimeMax ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._programEndTimeMax = newValue}
  }
  /// Returns true if `programEndTimeMax` has been explicitly set.
  var hasProgramEndTimeMax: Bool {return _storage._programEndTimeMax != nil}
  /// Clears the value of `programEndTimeMax`. Subsequent reads from it will return its default value.
  mutating func clearProgramEndTimeMax() {_uniqueStorage()._programEndTimeMax = nil}

  /// Used internally to calculate and track the current claim period's ending time.
  var claimPeriodEndTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._claimPeriodEndTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._claimPeriodEndTime = newValue}
  }
  /// Returns true if `claimPeriodEndTime` has been explicitly set.
  var hasClaimPeriodEndTime: Bool {return _storage._claimPeriodEndTime != nil}
  /// Clears the value of `claimPeriodEndTime`. Subsequent reads from it will return its default value.
  mutating func clearClaimPeriodEndTime() {_uniqueStorage()._claimPeriodEndTime = nil}

  /// Time the RewardProgram switched to FINISHED state. Initially set as empty.
  var actualProgramEndTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._actualProgramEndTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._actualProgramEndTime = newValue}
  }
  /// Returns true if `actualProgramEndTime` has been explicitly set.
  var hasActualProgramEndTime: Bool {return _storage._actualProgramEndTime != nil}
  /// Clears the value of `actualProgramEndTime`. Subsequent reads from it will return its default value.
  mutating func clearActualProgramEndTime() {_uniqueStorage()._actualProgramEndTime = nil}

  /// Number of claim periods this program will run for.
  var claimPeriods: UInt64 {
    get {return _storage._claimPeriods}
    set {_uniqueStorage()._claimPeriods = newValue}
  }

  /// Current claim period of the RewardProgram. Uses 1-based indexing.
  var currentClaimPeriod: UInt64 {
    get {return _storage._currentClaimPeriod}
    set {_uniqueStorage()._currentClaimPeriod = newValue}
  }

  /// maximum number of claim periods a reward program can rollover.
  var maxRolloverClaimPeriods: UInt64 {
    get {return _storage._maxRolloverClaimPeriods}
    set {_uniqueStorage()._maxRolloverClaimPeriods = newValue}
  }

  /// Current state of the RewardProgram.
  var state: Provenance_Reward_V1_RewardProgram.State {
    get {return _storage._state}
    set {_uniqueStorage()._state = newValue}
  }

  /// Grace period after a RewardProgram FINISHED. It is the number of seconds until a RewardProgram enters the EXPIRED
  /// state.
  var expirationOffset: UInt64 {
    get {return _storage._expirationOffset}
    set {_uniqueStorage()._expirationOffset = newValue}
  }

  /// Actions that count towards the reward.
  var qualifyingActions: [Provenance_Reward_V1_QualifyingAction] {
    get {return _storage._qualifyingActions}
    set {_uniqueStorage()._qualifyingActions = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// State is the state of the reward program
  enum State: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// undefined program state
    case unspecified // = 0

    /// pending state of reward program
    case pending // = 1

    /// started state of reward program
    case started // = 2

    /// finished state of reward program
    case finished // = 3

    /// expired state of reward program
    case expired // = 4
    case UNRECOGNIZED(Int)

    init() {
      self = .unspecified
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .pending
      case 2: self = .started
      case 3: self = .finished
      case 4: self = .expired
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .pending: return 1
      case .started: return 2
      case .finished: return 3
      case .expired: return 4
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension Provenance_Reward_V1_RewardProgram.State: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Provenance_Reward_V1_RewardProgram.State] = [
    .unspecified,
    .pending,
    .started,
    .finished,
    .expired,
  ]
}

#endif  // swift(>=4.2)

/// ClaimPeriodRewardDistribution, this is updated at the end of every claim period.
struct Provenance_Reward_V1_ClaimPeriodRewardDistribution {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The claim period id.
  var claimPeriodID: UInt64 = 0

  /// The id of the reward program that this reward belongs to.
  var rewardProgramID: UInt64 = 0

  /// The sum of all the granted rewards for this claim period.
  var totalRewardsPoolForClaimPeriod: Cosmos_Base_V1beta1_Coin {
    get {return _totalRewardsPoolForClaimPeriod ?? Cosmos_Base_V1beta1_Coin()}
    set {_totalRewardsPoolForClaimPeriod = newValue}
  }
  /// Returns true if `totalRewardsPoolForClaimPeriod` has been explicitly set.
  var hasTotalRewardsPoolForClaimPeriod: Bool {return self._totalRewardsPoolForClaimPeriod != nil}
  /// Clears the value of `totalRewardsPoolForClaimPeriod`. Subsequent reads from it will return its default value.
  mutating func clearTotalRewardsPoolForClaimPeriod() {self._totalRewardsPoolForClaimPeriod = nil}

  /// The final allocated rewards for this claim period.
  var rewardsPool: Cosmos_Base_V1beta1_Coin {
    get {return _rewardsPool ?? Cosmos_Base_V1beta1_Coin()}
    set {_rewardsPool = newValue}
  }
  /// Returns true if `rewardsPool` has been explicitly set.
  var hasRewardsPool: Bool {return self._rewardsPool != nil}
  /// Clears the value of `rewardsPool`. Subsequent reads from it will return its default value.
  mutating func clearRewardsPool() {self._rewardsPool = nil}

  /// The total number of granted shares for this claim period.
  var totalShares: Int64 = 0

  /// A flag representing if the claim period for this reward has ended.
  var claimPeriodEnded: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _totalRewardsPoolForClaimPeriod: Cosmos_Base_V1beta1_Coin? = nil
  fileprivate var _rewardsPool: Cosmos_Base_V1beta1_Coin? = nil
}

/// RewardAccountState contains state at the claim period level for a specific address.
struct Provenance_Reward_V1_RewardAccountState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The id of the reward program that this share belongs to.
  var rewardProgramID: UInt64 = 0

  /// The id of the claim period that the share belongs to.
  var claimPeriodID: UInt64 = 0

  /// Owner of the reward account state.
  var address: String = String()

  /// The number of actions performed by this account, mapped by action type.
  var actionCounter: [Provenance_Reward_V1_ActionCounter] = []

  /// The amount of granted shares for the address in the reward program's claim period.
  var sharesEarned: UInt64 = 0

  /// The status of the claim.
  var claimStatus: Provenance_Reward_V1_RewardAccountState.ClaimStatus = .unspecified

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// ClaimStatus is the state a claim is in
  enum ClaimStatus: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// undefined state
    case unspecified // = 0

    /// unclaimable status
    case unclaimable // = 1

    /// unclaimable claimable
    case claimable // = 2

    /// unclaimable claimed
    case claimed // = 3

    /// unclaimable expired
    case expired // = 4
    case UNRECOGNIZED(Int)

    init() {
      self = .unspecified
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .unclaimable
      case 2: self = .claimable
      case 3: self = .claimed
      case 4: self = .expired
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .unclaimable: return 1
      case .claimable: return 2
      case .claimed: return 3
      case .expired: return 4
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}
}

#if swift(>=4.2)

extension Provenance_Reward_V1_RewardAccountState.ClaimStatus: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Provenance_Reward_V1_RewardAccountState.ClaimStatus] = [
    .unspecified,
    .unclaimable,
    .claimable,
    .claimed,
    .expired,
  ]
}

#endif  // swift(>=4.2)

/// QualifyingAction can be one of many action types.
struct Provenance_Reward_V1_QualifyingAction {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// type of action to process
  var type: Provenance_Reward_V1_QualifyingAction.OneOf_Type? = nil

  var delegate: Provenance_Reward_V1_ActionDelegate {
    get {
      if case .delegate(let v)? = type {return v}
      return Provenance_Reward_V1_ActionDelegate()
    }
    set {type = .delegate(newValue)}
  }

  var transfer: Provenance_Reward_V1_ActionTransfer {
    get {
      if case .transfer(let v)? = type {return v}
      return Provenance_Reward_V1_ActionTransfer()
    }
    set {type = .transfer(newValue)}
  }

  var vote: Provenance_Reward_V1_ActionVote {
    get {
      if case .vote(let v)? = type {return v}
      return Provenance_Reward_V1_ActionVote()
    }
    set {type = .vote(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// type of action to process
  enum OneOf_Type: Equatable {
    case delegate(Provenance_Reward_V1_ActionDelegate)
    case transfer(Provenance_Reward_V1_ActionTransfer)
    case vote(Provenance_Reward_V1_ActionVote)

  #if !swift(>=4.1)
    static func ==(lhs: Provenance_Reward_V1_QualifyingAction.OneOf_Type, rhs: Provenance_Reward_V1_QualifyingAction.OneOf_Type) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.delegate, .delegate): return {
        guard case .delegate(let l) = lhs, case .delegate(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.transfer, .transfer): return {
        guard case .transfer(let l) = lhs, case .transfer(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.vote, .vote): return {
        guard case .vote(let l) = lhs, case .vote(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

/// QualifyingActions contains a list of QualifyingActions.
struct Provenance_Reward_V1_QualifyingActions {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The actions that count towards the reward.
  var qualifyingActions: [Provenance_Reward_V1_QualifyingAction] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// ActionDelegate represents the delegate action and its required eligibility criteria.
struct Provenance_Reward_V1_ActionDelegate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Minimum number of successful delegates.
  var minimumActions: UInt64 = 0

  /// Maximum number of successful delegates.
  var maximumActions: UInt64 = 0

  /// Minimum amount that the user must have currently delegated on the validator.
  var minimumDelegationAmount: Cosmos_Base_V1beta1_Coin {
    get {return _minimumDelegationAmount ?? Cosmos_Base_V1beta1_Coin()}
    set {_minimumDelegationAmount = newValue}
  }
  /// Returns true if `minimumDelegationAmount` has been explicitly set.
  var hasMinimumDelegationAmount: Bool {return self._minimumDelegationAmount != nil}
  /// Clears the value of `minimumDelegationAmount`. Subsequent reads from it will return its default value.
  mutating func clearMinimumDelegationAmount() {self._minimumDelegationAmount = nil}

  /// Maximum amount that the user must have currently delegated on the validator.
  var maximumDelegationAmount: Cosmos_Base_V1beta1_Coin {
    get {return _maximumDelegationAmount ?? Cosmos_Base_V1beta1_Coin()}
    set {_maximumDelegationAmount = newValue}
  }
  /// Returns true if `maximumDelegationAmount` has been explicitly set.
  var hasMaximumDelegationAmount: Bool {return self._maximumDelegationAmount != nil}
  /// Clears the value of `maximumDelegationAmount`. Subsequent reads from it will return its default value.
  mutating func clearMaximumDelegationAmount() {self._maximumDelegationAmount = nil}

  /// Minimum percentile that can be below the validator's power ranking.
  var minimumActiveStakePercentile: String = String()

  /// Maximum percentile that can be below the validator's power ranking.
  var maximumActiveStakePercentile: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _minimumDelegationAmount: Cosmos_Base_V1beta1_Coin? = nil
  fileprivate var _maximumDelegationAmount: Cosmos_Base_V1beta1_Coin? = nil
}

/// ActionTransfer represents the transfer action and its required eligibility criteria.
struct Provenance_Reward_V1_ActionTransfer {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Minimum number of successful transfers.
  var minimumActions: UInt64 = 0

  /// Maximum number of successful transfers.
  var maximumActions: UInt64 = 0

  /// Minimum delegation amount the account must have across all validators, for the transfer action to be counted.
  var minimumDelegationAmount: Cosmos_Base_V1beta1_Coin {
    get {return _minimumDelegationAmount ?? Cosmos_Base_V1beta1_Coin()}
    set {_minimumDelegationAmount = newValue}
  }
  /// Returns true if `minimumDelegationAmount` has been explicitly set.
  var hasMinimumDelegationAmount: Bool {return self._minimumDelegationAmount != nil}
  /// Clears the value of `minimumDelegationAmount`. Subsequent reads from it will return its default value.
  mutating func clearMinimumDelegationAmount() {self._minimumDelegationAmount = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _minimumDelegationAmount: Cosmos_Base_V1beta1_Coin? = nil
}

/// ActionVote represents the voting action and its required eligibility criteria.
struct Provenance_Reward_V1_ActionVote {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Minimum number of successful votes.
  var minimumActions: UInt64 = 0

  /// Maximum number of successful votes.
  var maximumActions: UInt64 = 0

  /// Minimum delegation amount the account must have across all validators, for the vote action to be counted.
  var minimumDelegationAmount: Cosmos_Base_V1beta1_Coin {
    get {return _minimumDelegationAmount ?? Cosmos_Base_V1beta1_Coin()}
    set {_minimumDelegationAmount = newValue}
  }
  /// Returns true if `minimumDelegationAmount` has been explicitly set.
  var hasMinimumDelegationAmount: Bool {return self._minimumDelegationAmount != nil}
  /// Clears the value of `minimumDelegationAmount`. Subsequent reads from it will return its default value.
  mutating func clearMinimumDelegationAmount() {self._minimumDelegationAmount = nil}

  /// Positive multiplier that is applied to the shares awarded by the vote action when conditions
  /// are met(for now the only condition is the current vote is a validator vote). A value of zero will behave the same
  /// as one
  var validatorMultiplier: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _minimumDelegationAmount: Cosmos_Base_V1beta1_Coin? = nil
}

/// ActionCounter is a key-value pair that maps action type to the number of times it was performed.
struct Provenance_Reward_V1_ActionCounter {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The type of action performed.
  var actionType: String = String()

  /// The number of times this action has been performed
  var numberOfActions: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Provenance_Reward_V1_RewardProgram: @unchecked Sendable {}
extension Provenance_Reward_V1_RewardProgram.State: @unchecked Sendable {}
extension Provenance_Reward_V1_ClaimPeriodRewardDistribution: @unchecked Sendable {}
extension Provenance_Reward_V1_RewardAccountState: @unchecked Sendable {}
extension Provenance_Reward_V1_RewardAccountState.ClaimStatus: @unchecked Sendable {}
extension Provenance_Reward_V1_QualifyingAction: @unchecked Sendable {}
extension Provenance_Reward_V1_QualifyingAction.OneOf_Type: @unchecked Sendable {}
extension Provenance_Reward_V1_QualifyingActions: @unchecked Sendable {}
extension Provenance_Reward_V1_ActionDelegate: @unchecked Sendable {}
extension Provenance_Reward_V1_ActionTransfer: @unchecked Sendable {}
extension Provenance_Reward_V1_ActionVote: @unchecked Sendable {}
extension Provenance_Reward_V1_ActionCounter: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "provenance.reward.v1"

extension Provenance_Reward_V1_RewardProgram: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RewardProgram"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "title"),
    3: .same(proto: "description"),
    4: .standard(proto: "distribute_from_address"),
    5: .standard(proto: "total_reward_pool"),
    6: .standard(proto: "remaining_pool_balance"),
    7: .standard(proto: "claimed_amount"),
    8: .standard(proto: "max_reward_by_address"),
    9: .standard(proto: "minimum_rollover_amount"),
    10: .standard(proto: "claim_period_seconds"),
    11: .standard(proto: "program_start_time"),
    12: .standard(proto: "expected_program_end_time"),
    13: .standard(proto: "program_end_time_max"),
    14: .standard(proto: "claim_period_end_time"),
    15: .standard(proto: "actual_program_end_time"),
    16: .standard(proto: "claim_periods"),
    17: .standard(proto: "current_claim_period"),
    18: .standard(proto: "max_rollover_claim_periods"),
    19: .same(proto: "state"),
    20: .standard(proto: "expiration_offset"),
    21: .standard(proto: "qualifying_actions"),
  ]

  fileprivate class _StorageClass {
    var _id: UInt64 = 0
    var _title: String = String()
    var _description_p: String = String()
    var _distributeFromAddress: String = String()
    var _totalRewardPool: Cosmos_Base_V1beta1_Coin? = nil
    var _remainingPoolBalance: Cosmos_Base_V1beta1_Coin? = nil
    var _claimedAmount: Cosmos_Base_V1beta1_Coin? = nil
    var _maxRewardByAddress: Cosmos_Base_V1beta1_Coin? = nil
    var _minimumRolloverAmount: Cosmos_Base_V1beta1_Coin? = nil
    var _claimPeriodSeconds: UInt64 = 0
    var _programStartTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _expectedProgramEndTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _programEndTimeMax: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _claimPeriodEndTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _actualProgramEndTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _claimPeriods: UInt64 = 0
    var _currentClaimPeriod: UInt64 = 0
    var _maxRolloverClaimPeriods: UInt64 = 0
    var _state: Provenance_Reward_V1_RewardProgram.State = .unspecified
    var _expirationOffset: UInt64 = 0
    var _qualifyingActions: [Provenance_Reward_V1_QualifyingAction] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _title = source._title
      _description_p = source._description_p
      _distributeFromAddress = source._distributeFromAddress
      _totalRewardPool = source._totalRewardPool
      _remainingPoolBalance = source._remainingPoolBalance
      _claimedAmount = source._claimedAmount
      _maxRewardByAddress = source._maxRewardByAddress
      _minimumRolloverAmount = source._minimumRolloverAmount
      _claimPeriodSeconds = source._claimPeriodSeconds
      _programStartTime = source._programStartTime
      _expectedProgramEndTime = source._expectedProgramEndTime
      _programEndTimeMax = source._programEndTimeMax
      _claimPeriodEndTime = source._claimPeriodEndTime
      _actualProgramEndTime = source._actualProgramEndTime
      _claimPeriods = source._claimPeriods
      _currentClaimPeriod = source._currentClaimPeriod
      _maxRolloverClaimPeriods = source._maxRolloverClaimPeriods
      _state = source._state
      _expirationOffset = source._expirationOffset
      _qualifyingActions = source._qualifyingActions
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularUInt64Field(value: &_storage._id) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._title) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._description_p) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._distributeFromAddress) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._totalRewardPool) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._remainingPoolBalance) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._claimedAmount) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._maxRewardByAddress) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._minimumRolloverAmount) }()
        case 10: try { try decoder.decodeSingularUInt64Field(value: &_storage._claimPeriodSeconds) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._programStartTime) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._expectedProgramEndTime) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._programEndTimeMax) }()
        case 14: try { try decoder.decodeSingularMessageField(value: &_storage._claimPeriodEndTime) }()
        case 15: try { try decoder.decodeSingularMessageField(value: &_storage._actualProgramEndTime) }()
        case 16: try { try decoder.decodeSingularUInt64Field(value: &_storage._claimPeriods) }()
        case 17: try { try decoder.decodeSingularUInt64Field(value: &_storage._currentClaimPeriod) }()
        case 18: try { try decoder.decodeSingularUInt64Field(value: &_storage._maxRolloverClaimPeriods) }()
        case 19: try { try decoder.decodeSingularEnumField(value: &_storage._state) }()
        case 20: try { try decoder.decodeSingularUInt64Field(value: &_storage._expirationOffset) }()
        case 21: try { try decoder.decodeRepeatedMessageField(value: &_storage._qualifyingActions) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._id != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._id, fieldNumber: 1)
      }
      if !_storage._title.isEmpty {
        try visitor.visitSingularStringField(value: _storage._title, fieldNumber: 2)
      }
      if !_storage._description_p.isEmpty {
        try visitor.visitSingularStringField(value: _storage._description_p, fieldNumber: 3)
      }
      if !_storage._distributeFromAddress.isEmpty {
        try visitor.visitSingularStringField(value: _storage._distributeFromAddress, fieldNumber: 4)
      }
      try { if let v = _storage._totalRewardPool {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._remainingPoolBalance {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._claimedAmount {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._maxRewardByAddress {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._minimumRolloverAmount {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      if _storage._claimPeriodSeconds != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._claimPeriodSeconds, fieldNumber: 10)
      }
      try { if let v = _storage._programStartTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._expectedProgramEndTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
      try { if let v = _storage._programEndTimeMax {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      } }()
      try { if let v = _storage._claimPeriodEndTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      } }()
      try { if let v = _storage._actualProgramEndTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      } }()
      if _storage._claimPeriods != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._claimPeriods, fieldNumber: 16)
      }
      if _storage._currentClaimPeriod != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._currentClaimPeriod, fieldNumber: 17)
      }
      if _storage._maxRolloverClaimPeriods != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._maxRolloverClaimPeriods, fieldNumber: 18)
      }
      if _storage._state != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._state, fieldNumber: 19)
      }
      if _storage._expirationOffset != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._expirationOffset, fieldNumber: 20)
      }
      if !_storage._qualifyingActions.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._qualifyingActions, fieldNumber: 21)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Reward_V1_RewardProgram, rhs: Provenance_Reward_V1_RewardProgram) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._title != rhs_storage._title {return false}
        if _storage._description_p != rhs_storage._description_p {return false}
        if _storage._distributeFromAddress != rhs_storage._distributeFromAddress {return false}
        if _storage._totalRewardPool != rhs_storage._totalRewardPool {return false}
        if _storage._remainingPoolBalance != rhs_storage._remainingPoolBalance {return false}
        if _storage._claimedAmount != rhs_storage._claimedAmount {return false}
        if _storage._maxRewardByAddress != rhs_storage._maxRewardByAddress {return false}
        if _storage._minimumRolloverAmount != rhs_storage._minimumRolloverAmount {return false}
        if _storage._claimPeriodSeconds != rhs_storage._claimPeriodSeconds {return false}
        if _storage._programStartTime != rhs_storage._programStartTime {return false}
        if _storage._expectedProgramEndTime != rhs_storage._expectedProgramEndTime {return false}
        if _storage._programEndTimeMax != rhs_storage._programEndTimeMax {return false}
        if _storage._claimPeriodEndTime != rhs_storage._claimPeriodEndTime {return false}
        if _storage._actualProgramEndTime != rhs_storage._actualProgramEndTime {return false}
        if _storage._claimPeriods != rhs_storage._claimPeriods {return false}
        if _storage._currentClaimPeriod != rhs_storage._currentClaimPeriod {return false}
        if _storage._maxRolloverClaimPeriods != rhs_storage._maxRolloverClaimPeriods {return false}
        if _storage._state != rhs_storage._state {return false}
        if _storage._expirationOffset != rhs_storage._expirationOffset {return false}
        if _storage._qualifyingActions != rhs_storage._qualifyingActions {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Reward_V1_RewardProgram.State: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STATE_UNSPECIFIED"),
    1: .same(proto: "STATE_PENDING"),
    2: .same(proto: "STATE_STARTED"),
    3: .same(proto: "STATE_FINISHED"),
    4: .same(proto: "STATE_EXPIRED"),
  ]
}

extension Provenance_Reward_V1_ClaimPeriodRewardDistribution: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ClaimPeriodRewardDistribution"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "claim_period_id"),
    2: .standard(proto: "reward_program_id"),
    3: .standard(proto: "total_rewards_pool_for_claim_period"),
    4: .standard(proto: "rewards_pool"),
    5: .standard(proto: "total_shares"),
    6: .standard(proto: "claim_period_ended"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.claimPeriodID) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.rewardProgramID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._totalRewardsPoolForClaimPeriod) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._rewardsPool) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.totalShares) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.claimPeriodEnded) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.claimPeriodID != 0 {
      try visitor.visitSingularUInt64Field(value: self.claimPeriodID, fieldNumber: 1)
    }
    if self.rewardProgramID != 0 {
      try visitor.visitSingularUInt64Field(value: self.rewardProgramID, fieldNumber: 2)
    }
    try { if let v = self._totalRewardsPoolForClaimPeriod {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._rewardsPool {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if self.totalShares != 0 {
      try visitor.visitSingularInt64Field(value: self.totalShares, fieldNumber: 5)
    }
    if self.claimPeriodEnded != false {
      try visitor.visitSingularBoolField(value: self.claimPeriodEnded, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Reward_V1_ClaimPeriodRewardDistribution, rhs: Provenance_Reward_V1_ClaimPeriodRewardDistribution) -> Bool {
    if lhs.claimPeriodID != rhs.claimPeriodID {return false}
    if lhs.rewardProgramID != rhs.rewardProgramID {return false}
    if lhs._totalRewardsPoolForClaimPeriod != rhs._totalRewardsPoolForClaimPeriod {return false}
    if lhs._rewardsPool != rhs._rewardsPool {return false}
    if lhs.totalShares != rhs.totalShares {return false}
    if lhs.claimPeriodEnded != rhs.claimPeriodEnded {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Reward_V1_RewardAccountState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RewardAccountState"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "reward_program_id"),
    2: .standard(proto: "claim_period_id"),
    3: .same(proto: "address"),
    4: .standard(proto: "action_counter"),
    5: .standard(proto: "shares_earned"),
    6: .standard(proto: "claim_status"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.rewardProgramID) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.claimPeriodID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.address) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.actionCounter) }()
      case 5: try { try decoder.decodeSingularUInt64Field(value: &self.sharesEarned) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self.claimStatus) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.rewardProgramID != 0 {
      try visitor.visitSingularUInt64Field(value: self.rewardProgramID, fieldNumber: 1)
    }
    if self.claimPeriodID != 0 {
      try visitor.visitSingularUInt64Field(value: self.claimPeriodID, fieldNumber: 2)
    }
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 3)
    }
    if !self.actionCounter.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.actionCounter, fieldNumber: 4)
    }
    if self.sharesEarned != 0 {
      try visitor.visitSingularUInt64Field(value: self.sharesEarned, fieldNumber: 5)
    }
    if self.claimStatus != .unspecified {
      try visitor.visitSingularEnumField(value: self.claimStatus, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Reward_V1_RewardAccountState, rhs: Provenance_Reward_V1_RewardAccountState) -> Bool {
    if lhs.rewardProgramID != rhs.rewardProgramID {return false}
    if lhs.claimPeriodID != rhs.claimPeriodID {return false}
    if lhs.address != rhs.address {return false}
    if lhs.actionCounter != rhs.actionCounter {return false}
    if lhs.sharesEarned != rhs.sharesEarned {return false}
    if lhs.claimStatus != rhs.claimStatus {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Reward_V1_RewardAccountState.ClaimStatus: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CLAIM_STATUS_UNSPECIFIED"),
    1: .same(proto: "CLAIM_STATUS_UNCLAIMABLE"),
    2: .same(proto: "CLAIM_STATUS_CLAIMABLE"),
    3: .same(proto: "CLAIM_STATUS_CLAIMED"),
    4: .same(proto: "CLAIM_STATUS_EXPIRED"),
  ]
}

extension Provenance_Reward_V1_QualifyingAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QualifyingAction"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "delegate"),
    2: .same(proto: "transfer"),
    3: .same(proto: "vote"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Provenance_Reward_V1_ActionDelegate?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .delegate(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .delegate(v)
        }
      }()
      case 2: try {
        var v: Provenance_Reward_V1_ActionTransfer?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .transfer(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .transfer(v)
        }
      }()
      case 3: try {
        var v: Provenance_Reward_V1_ActionVote?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .vote(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .vote(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.type {
    case .delegate?: try {
      guard case .delegate(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .transfer?: try {
      guard case .transfer(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .vote?: try {
      guard case .vote(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Reward_V1_QualifyingAction, rhs: Provenance_Reward_V1_QualifyingAction) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Reward_V1_QualifyingActions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QualifyingActions"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "qualifying_actions"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.qualifyingActions) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.qualifyingActions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.qualifyingActions, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Reward_V1_QualifyingActions, rhs: Provenance_Reward_V1_QualifyingActions) -> Bool {
    if lhs.qualifyingActions != rhs.qualifyingActions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Reward_V1_ActionDelegate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ActionDelegate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "minimum_actions"),
    2: .standard(proto: "maximum_actions"),
    3: .standard(proto: "minimum_delegation_amount"),
    4: .standard(proto: "maximum_delegation_amount"),
    5: .standard(proto: "minimum_active_stake_percentile"),
    6: .standard(proto: "maximum_active_stake_percentile"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.minimumActions) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.maximumActions) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._minimumDelegationAmount) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._maximumDelegationAmount) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.minimumActiveStakePercentile) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.maximumActiveStakePercentile) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.minimumActions != 0 {
      try visitor.visitSingularUInt64Field(value: self.minimumActions, fieldNumber: 1)
    }
    if self.maximumActions != 0 {
      try visitor.visitSingularUInt64Field(value: self.maximumActions, fieldNumber: 2)
    }
    try { if let v = self._minimumDelegationAmount {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._maximumDelegationAmount {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if !self.minimumActiveStakePercentile.isEmpty {
      try visitor.visitSingularStringField(value: self.minimumActiveStakePercentile, fieldNumber: 5)
    }
    if !self.maximumActiveStakePercentile.isEmpty {
      try visitor.visitSingularStringField(value: self.maximumActiveStakePercentile, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Reward_V1_ActionDelegate, rhs: Provenance_Reward_V1_ActionDelegate) -> Bool {
    if lhs.minimumActions != rhs.minimumActions {return false}
    if lhs.maximumActions != rhs.maximumActions {return false}
    if lhs._minimumDelegationAmount != rhs._minimumDelegationAmount {return false}
    if lhs._maximumDelegationAmount != rhs._maximumDelegationAmount {return false}
    if lhs.minimumActiveStakePercentile != rhs.minimumActiveStakePercentile {return false}
    if lhs.maximumActiveStakePercentile != rhs.maximumActiveStakePercentile {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Reward_V1_ActionTransfer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ActionTransfer"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "minimum_actions"),
    2: .standard(proto: "maximum_actions"),
    3: .standard(proto: "minimum_delegation_amount"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.minimumActions) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.maximumActions) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._minimumDelegationAmount) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.minimumActions != 0 {
      try visitor.visitSingularUInt64Field(value: self.minimumActions, fieldNumber: 1)
    }
    if self.maximumActions != 0 {
      try visitor.visitSingularUInt64Field(value: self.maximumActions, fieldNumber: 2)
    }
    try { if let v = self._minimumDelegationAmount {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Reward_V1_ActionTransfer, rhs: Provenance_Reward_V1_ActionTransfer) -> Bool {
    if lhs.minimumActions != rhs.minimumActions {return false}
    if lhs.maximumActions != rhs.maximumActions {return false}
    if lhs._minimumDelegationAmount != rhs._minimumDelegationAmount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Reward_V1_ActionVote: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ActionVote"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "minimum_actions"),
    2: .standard(proto: "maximum_actions"),
    3: .standard(proto: "minimum_delegation_amount"),
    4: .standard(proto: "validator_multiplier"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.minimumActions) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.maximumActions) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._minimumDelegationAmount) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.validatorMultiplier) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.minimumActions != 0 {
      try visitor.visitSingularUInt64Field(value: self.minimumActions, fieldNumber: 1)
    }
    if self.maximumActions != 0 {
      try visitor.visitSingularUInt64Field(value: self.maximumActions, fieldNumber: 2)
    }
    try { if let v = self._minimumDelegationAmount {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if self.validatorMultiplier != 0 {
      try visitor.visitSingularUInt64Field(value: self.validatorMultiplier, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Reward_V1_ActionVote, rhs: Provenance_Reward_V1_ActionVote) -> Bool {
    if lhs.minimumActions != rhs.minimumActions {return false}
    if lhs.maximumActions != rhs.maximumActions {return false}
    if lhs._minimumDelegationAmount != rhs._minimumDelegationAmount {return false}
    if lhs.validatorMultiplier != rhs.validatorMultiplier {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Reward_V1_ActionCounter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ActionCounter"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "action_type"),
    2: .standard(proto: "number_of_actions"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.actionType) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.numberOfActions) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.actionType.isEmpty {
      try visitor.visitSingularStringField(value: self.actionType, fieldNumber: 1)
    }
    if self.numberOfActions != 0 {
      try visitor.visitSingularUInt64Field(value: self.numberOfActions, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Reward_V1_ActionCounter, rhs: Provenance_Reward_V1_ActionCounter) -> Bool {
    if lhs.actionType != rhs.actionType {return false}
    if lhs.numberOfActions != rhs.numberOfActions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
